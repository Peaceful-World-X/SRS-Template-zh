# 软件需求规格
## 对于 {{project name}}

版本 0.1  
由 {{author}} 编写  
{{organization}}  
{{date_modified}}

## 目录
<!-- TOC -->
* [1. 导言](#1-导言)
    * [1.1 文件目的](#11-文件目的)
    * [1.2 产品范围](#12-产品范围)
    * [1.3 定义、缩略语和简称](#13-定义缩略语和简称)
    * [1.4 参考资料](#14-参考资料)
    * [1.5 文档概述](#15-文档概述)
* [2. 产品概述](#2-产品概述)
    * [2.1 产品视角](#21-产品视角)
    * [2.2 产品功能](#22-产品功能)
    * [2.3 产品限制](#23-产品限制)
    * [2.4 用户特征](#24-用户特征)
    * [2.5 假设和依赖性](#25-假设和依赖性)
    * [2.6 分配需求](#26-分配需求)
* [3. 要求](#3-要求)
    * [3.1 外部接口](#31-外部接口)
    * [3.2 功能](#32-功能)
    * [3.3 服务质量](#33-服务质量)
    * [3.4 合规性](#34-合规性)
    * [3.5 设计和实施](#35-设计和实施)
    * [3.6 AI/ML](#36-aiml)
* [4. 验证](#4-验证)
* [5. 附录](#5-附录)
<!-- TOC -->

## 修订历史

| Name | Date | Reason For Changes | Version |
|------|------|--------------------|---------|
|      |      |                    |         |
|      |      |                    |         |

## 1. 导言
💬 _概述文件内容，让读者了解所指定的系统。_

➥ 简要概述 SRS 的目的、产品范围、预期受众以及文件的组织方式。此处不要包含细节，请参考相关章节。

### 1.1 文件目的
💬 _说明该 SRS 存在的原因、包含的内容以及使用对象。_

➥ 用 2-4 句话说明 SRS 的目的。指出主要受众（如产品、工程、质量保证、安全、合规、运营），以及他们在整个软件生命周期中如何使用该系统。

💡 提示：
- 强调 SRS 定义的是系统必须做什么，而不是如何做。
- 如果相关，请提及相关文档（愿景/范围、架构、路线图、合同）。

### 1.2 产品范围
💬 _定义软件产品的目的、边界以及与业务目标的关系。_

➥ 用名称和版本/发布版本标识产品。用 3-5 句话描述其主要目的、关键功能和预期成果。当本 SRS 涵盖较大系统的一部分时，应明确列出包含和不包含的内容。重点说明 "是什么 "和 "为什么"。

💡 提示：
- 将能力与业务目标联系起来，并在相关情况下参考单独的愿景/范围文件。
- 如果能明确更大系统内的界限，可包含一个简单的图表。

### 1.3 定义、缩略语和简称
➥ 通过提供 SRS 中使用的领域术语、缩略语和缩写词的词汇表，帮助读者理解专业术语和符号。

💡 提示：
- 包括影响需求解释的术语（如 "用户"、"租户"、"近实时"）。
- 保持条目按字母顺序排列，并在整套文件中保持一致。

| Term | Definition                                                                                                                   |
|------|------------------------------------------------------------------------------------------------------------------------------|
| API  | Application Programming Interface - A set of definitions and protocols for building and integrating application software     |
| SRS  | Software Requirements Specification - A document that describes the intended purpose, requirements, and nature of a software |
| UI   | User Interface - The visual part of computer application through which a user interacts with a software                      |

### 1.4 参考资料
💬 _列出对本 SRS 具有规范性或参考性的外部来源。_

➥ 引用标准、合同、政策、界面规范、用户体验风格指南、用例文档、架构决策或愿景/范围文档。对于每份参考资料，请注明标题、作者/所有者、版本、日期和位置/URL。指明每份参考资料是规范性（约束性）还是信息性（指导性）。

💡 提示：
- 优先选择稳定的链接或资源库路径，而不是不稳定的 URL。

### 1.5 文档概述
💬 _简要介绍 SRS 的结构，以便读者快速找到所需内容。_

➥ 概述每个主要部分的内容（产品概述、需求、验证、附录），注意任何文件约定，并提及如何管理更新和修订历史。

💡 提示：
- 以 3-5 句话为宜，重点介绍导航和惯例。

## 2. 产品概述
💬 _提供影响产品需求的背景和环境。_

### 2.1 产品视角
💬 _将产品置于更大的生态系统或产品系列中。_

➥ 描述产品的背景和起源，是新产品、替代产品还是家族成员。如果是更大系统的一部分，简要说明关系、外部接口和主要依赖关系。包括所有权、服务水平协议（SLA）和支持模式的详细信息。

💡 提示：
- 突出上游/下游系统和所有权边界。
- 高水平的背景图可帮助读者确定方向。

### 2.2 产品功能
💬 _高度概括产品能让用户或系统做什么。_

➥ 简明扼要地概述主要功能领域/特性。将详细的行为、数据和边缘案例推迟到第 3 节。

💡 提示：
- 在这个层次上，通常用 5-10 个小标题就足够了，将相关功能按逻辑分组。
- 如果有帮助，请附上顶层数据流或用例图。

### 2.3 产品限制
💬 _定义影响设计和实施的背景限制或条件。_

➥ 描述各种限制因素，如规定的接口、技术堆栈、监管义务、服务质量基线、硬件限制、人工智能/ML 模型族和组织政策。

💡 提示：
- 以可验证的 "必须 "声明（如 "必须使用经 FIPS 140-3 验证的加密模块"）来说明限制因素。
- 区分外部/内部约束和强制/首选约束。
- 避免设计决策，除非真正具有约束力。

📝 注意：
要求（第 3 节）定义了可验证的系统义务--系统应表现出的特定行为或品质，以满足本节所述的限制。

### 2.4 用户特征
💬 _定义用户群和影响需求的属性。_

➥ 确定用户类别、角色和人物，注意专业知识、访问级别、使用频率、可访问性需求和目标。

💡 提示：
- 通过行为而不仅仅是标题来定义用户类别。
- 注意影响用户界面/用户体验要求的本地化和无障碍考虑因素。

### 2.5 假设和依赖性
💬 _项目所依赖的外部假定因素或条件，而非已知事实。_

➥ 列出对环境、硬件、使用模式、第三方组件/服务和组织支持的假设。列出对外部系统、库或团队的依赖。针对每项假设，说明如果证明是错误的，可能产生的影响。

💡 提示：
- 将假设与风险登记册联系起来，并注明所有者和缓解措施（如有）。

### 2.6 分配需求
💬 _在组件或增量中分配需求。_

➥ 将主要需求映射到子系统、服务或版本/迭代。使用交叉引用表来显示分配情况，并清楚地识别推迟的需求。

💡 提示：
- 明确指出未知的分配，并作为后续事项进行跟踪。

## 3. 要求
💬 _这部分规定了软件产品的可验证要求，以便进行设计和测试。_

➥ 要求的详细程度应足以进行设计和验证。使用唯一的标识符、一致的关键字（应/应当/可以）和明确的条件。描述输入、响应处理和输出（如适用）。参考需求涉及的相关 2.3 产品限制。

📃 模板（适用于所有需求）：
```markdown
- ID: REQ-FUNC-001
- Title: 简短标题，代表需求...
- Statement: 系统应...
- Rationale: ...
- Acceptance Criteria: ...
- Verification Method: 测试 | 分析 | 检验 | 演示 | 其他
- More Information: 附加背景。相关工件链接。
```

需求 ID 模式和可追溯性：
- ID 格式：REQ-[AREA]-[NNN]-[VER]（如有版本，可选-[VER]），其中 AREA ∈ {FUNC、INT、PERF、SEC、REL、AVAIL、OBS、COMP、INST、BUILD、DIST、MAINT、REUSE、PORT、COST、DEAD、POC、CM、ML}。
- 唯一性：ID 必须是唯一且不可更改的；更改会递增-[VER]，并记录在修订历史中。
- 可追溯性：每个测试工件都可以引用需求 ID。

💡 提示：
- 使用标准衡量标准，避免使用含糊不清的术语（如 "用户友好"、"快速"），使每个需求都可测试且明确无误。

### 3.1 外部接口
💬 _指定所有外部输入和输出，包括所需和提供的接口。_

➥ 提供足以实施和测试的接口定义。

💡 提示：
- 酌情使用接口控制文档或模式，并在此引用。

#### 3.1.1 用户界面
💬 _描述用户如何在逻辑层面上与系统交互。_

➥ 定义用户界面元素、流程和应遵循的标准（样式指南、可访问性指南）。包括布局限制、常用控件（如帮助、搜索）、键盘快捷键、错误/空状态行为和本地化。将可视化设计保存在单独的用户界面规范中并加以参考。

💡 提示：
- 参考可访问性标准（如 WCAG）和特定平台指南。
- 考虑组织成子类别，以提高清晰度：可用性/可访问性（输入/输出和对话框，以适应用户的抽象概念、能力和期望）和便利性。

#### 3.1.2 硬件接口
💬 _详细说明与物理设备和平台的交互。_

➥ 说明（不）支持的设备类型、数据/控制信号、电气或机械特性（如果相关）以及通信协议。包括时序、吞吐量和可靠性预期。

💡 提示：
- 参考适用的硬件规格和认证要求。

#### 3.1.3 软件界面
💬 _定义与其他软件组件和服务的集成。_

➥ 列出连接的系统（名称和版本）、所需或提供的服务/API、交换的数据项/信息、通信方式/协议以及限制/错误/超时语义。确定共享数据和所有权。

💡 提示：
- 获取版本和向后兼容性策略。
- 为每个集成定义认证/授权预期。

### 3.2 功能
💬 _指定软件应提供的外部可观察行为和功能。_

➥ 按功能、用例或服务组织功能需求。针对每种情况，描述触发/输入、处理/逻辑（黑盒级别）、输出和错误条件。对于人工智能行为，应定义确定性边界（如温度）、拒绝标准、安全规则和人工审核点。

💡 提示：
- 包括边缘情况和负面情况，以确保完整性。
- 对于人工智能功能，应包括后备行为和弃权阈值。

### 3.3 服务质量
💬 _限制或限定功能行为的质量属性。_

➥ 使用特定的指标、范围和条件。

💡 提示：
- 当质量只适用于功能子集时，请参考相关的需求 ID。
- 当目标跨越功能时，应提供理由以帮助做出权衡决策。

#### 3.3.1 性能
💬 _响应时间、吞吐量和资源使用预期。_

➥ 说明时间关系、峰值/稳态负载以及预期条件下的性能目标。包括测量方法、环境和接受阈值。注意任何实时限制。

💡 提示：
- 包括可扩展性目标和容量规划假设。
- 考虑分门别类以提高清晰度：时间（延迟、吞吐量等）和空间（内存、存储、带宽等）。

#### 3.3.2 安全性
💬 _定义对数据、身份和操作的保护。_

➥ 定义身份验证、授权、数据保护（传输中/静态）、审计和隐私要求。处理滥用/误用和外部攻击（如注入、数据外渗或服务破坏），并包括安全默认值和事件响应要求。

💡 提示：
- 区分强制控制与推荐实践。
- 考虑分门别类，以提高清晰度：安全性（有害的外部结果）、保密性（向未经授权的各方披露数据）、隐私性（未经同意披露私人数据）、完整性（未经授权修改数据）和可用性（应要求提供经授权的数据或资源）。

📝 注意：
将通用安全控制放在此处（3.3.2），必要时与支持的控制交叉引用：
- 使用 3.1 外部接口进行接口级验证和安全协议。
- 使用 3.4 合规性，了解监管/合同义务和审计证据。
- 使用 3.6 AI/ML，进行特定模型运行时保护和数据管理。

#### 3.3.3 可靠性
💬 _能够始终如一地按照规定执行。_

➥ 指定可靠性指标和技术（如 MTBF、错误预算、重试/回退、惰性、冗余）。定义评估可靠性的条件和任何故障切换行为。定义优美降级（如回退组件、缓存结果、AI/ML 确定性启发式）、超时/中止策略以及回滚到先前版本。

#### 3.3.4 可用性
💬 _系统正常运行时间和提供服务的准备状态。_

➥ 定义可用性目标、维护窗口以及检查点、恢复和重启等机制。包括地理/区域冗余（如适用）。

💡 提示：
- 用对用户有意义的术语表达可用性（如每月停机时间），并与 SLA/SLO 相结合。
- 捕捉影响可用性的扩展出/入行为（如最大故障切换时间、法定人数限制）。

#### 3.3.5 可观察性
💬 _能够通过遥测了解生产中的系统状态和行为。_

➥ 定义日志、度量、跟踪和剖析的要求：事件/字段、明细限制、采样、保留以及遥测中的隐私/PII 处理。指定标准标签（如服务、版本、租户）、相关性/跟踪 ID 传播和编辑策略。制定与 SLO 一致的警报规则、仪表盘和所有权。

💡 提示：
- 避免维护流程细节（在 3.5.4 可维护性中保留运行手册和待命策略）。

### 3.4 合规性
💬 _为满足外部标准、法规或合同而衍生的要求。_

➥ 明确规定格式、命名约定、会计程序、提供者/用户权利和协议、许可协议、审计跟踪、记录保留和报告。对于每个合规项目，请参考 2.3 产品限制（如适用），或直接引用权威来源。

### 3.5 设计和实施
💬 _影响解决方案设计、部署和维护的限制或规定。_

#### 3.5.1 安装
💬 _确保软件在目标环境中顺利运行。_

➥ 定义（不）受支持的平台/环境、先决条件、安装方法、环境配置（如 env vars、secret）以及回滚/卸载程序。

💡 提示：
- 详细说明自动化预期（如 IaC、安装程序脚本、容器镜像）。
- 在 3.5.3 Distribution 中保留扩展机制（拓扑、多区域）；在 3.3 QoS 中保留扩展目标。

#### 3.5.2 构建和交付
💬 _定义构建、打包和交付软件工件的控制措施，以确保完整性、可追溯性和可重现性。_

➥ 定义如何将源代码转换为可部署的工件并在环境中移动。描述对构建可重现性、依赖性管理、许可、配置管理、工件验证和发布推广的期望。

💡 提示：
- 交叉参考 3.5.1 安装和 3.5.10 变更管理，了解环境设置、版本和发布的可追溯性。
- 避免操作拓扑细节（属于 3.5.3 发布）。

#### 3.5.3 分发
💬 _处理地理或组织分布式部署、数据和设备。_

➥ 指定部署拓扑、组件和数据分布/复制方法、扩展运行手册，以及组织或网络结构施加的限制。

#### 3.5.4 可维护性
💬 _使软件更易于修改、修复和发展的属性。_

➥ 定义对模块化、代码复杂性、接口、编码标准、面向开发人员的可观察性、文档、软件交付性能和技术债务管理的期望。

#### 3.5.5 重用性
💬 _鼓励在适当的时候跨产品或跨环境使用组件。_

➥ 确定打算重复使用的组件，以及对其依赖关系或技术选择的限制。规定模块化、应用程序接口稳定性、打包和文档，以实现重用。

#### 3.5.6 可移植性
💬 _能够以最小的改动在多个平台或环境中运行。_

➥ 指定（不）支持的操作系统、硬件架构、云提供商或容器运行时。定义抽象层、配置策略和特定环境设置的外部化。

#### 3.5.7 成本
💬 _财务考虑或成本目标。_

➥ 说明影响设计决策的预算限制、每笔交易成本目标、许可限制或云支出范围。

💡 提示：
- 除非合同有明确规定，否则成本应保持在较高水平。
- 如果有成本模型或总体拥有成本假设，请链接至成本模型或总体拥有成本假设。
- 注意影响扩展策略的可变成本与固定成本预期。

#### 3.5.8 截止日期
💬 _影响范围和优先级的进度预期。_

➥ 明确关键里程碑、交付日期或阶段/增量。指出里程碑与所需准备就绪标准之间的依赖关系。

💡 提示：
- 使用截止日期来指导需求分配（第 2.6 节）。

#### 3.5.9 概念验证
💬 _在全面交付前验证可行性并消除关键假设的风险。_

➥ 定义任何 POC 的目标、范围、成功标准和时限。说明要验证的内容（技术、可用性、性能），以及验证结果将如何影响需求或设计。

💡 提示：
- 使 POC 专注于有限的范围并可衡量。关注验证目标，而不是实施细节。

#### 3.5.10 变更管理
💬 _控制变更的引入和沟通方式。_

➥ 定义变更类别（破坏性、添加性、错误修复）、审批工作流程和所需的工件（变更日志、评估摘要、迁移指南、发布说明）。指定向后/向前兼容性保证、客户沟通计划、报废时间表以及推出/回滚程序。

### 3.6 AI/ML
💬 _本节定义了以机器学习或数据驱动组件为核心的系统所特有的要求。这些要求补充了前几节中的功能、质量和设计方面的内容，但也涉及机器学习特有的生命周期、数据和道德方面的考虑。_

#### 3.6.1 模型规范
💬 _定义每个模型要做什么，以及可接受性能的衡量标准。_

➥ 描述模型的目的、范围、预期行为、关键输入和输出以及可测量的性能目标。说明为确保可重复性而使用的任何验证数据集、基准或版本实践。

💡 提示：
- 区分基线目标与期望的改进，并定义可接受的漂移容忍度。

#### 3.6.2 数据管理
💬 _确保模型训练、验证和运行中所使用数据的完整性、可追溯性和道德生命周期。_

➥ 明确数据集的来源、所有权、同意条件；标注流程和质量控制；数据来源、版本和可重现性（训练→验证→推理）；存储、访问控制和匿名化/假名化标准；缺失、合成或增强数据的处理。

#### 3.6.3 防护栏
💬 _确保人工智能系统在安全、可预测的范围内运行。_

➥ 说明系统如何验证输入、过滤或限制输出以及限制可用操作，以防止伤害、误用或意外后果。包括检测和响应恶意输入或不安全运行条件的机制。

💡 提示：
- 在输入、输出和操作层之间设置 "防护栏"。
- 定义触发安全限制时的升级、日志记录和回滚程序。
- 交叉参考 3.3.2 安全性中的系统级保护和 3.6.4 道德规范中的规范预期。

#### 3.6.4 道德规范
💬 _解决模型行为和结果的公平性、透明度和责任性问题。_

➥ 定义如何在整个开发和运行过程中识别、衡量和管理道德因素。包括公平性目标、可解释性预期以及文档或审核要求。

💡 提示：
- 使用适合具体情况的公平衡量标准（如人口均等、机会均等）。
- 考虑分门别类，以提高清晰度：公平性（结果中的社会偏差）、可解释性（可检查模型并理解输出结果）和可解释性（可解释给定输入的输出结果）。
- 与 3.6.3 关于执行机制的 Guardrails 和 3.6.5 关于人为监督的 Human-in-the-Loop 相协调。

#### 3.6.5 人在回路中
💬 _明确人类监督在机器学习模型影响或决策中的作用。_

➥ 说明在哪些方面以及如何需要人工审核、批准或干预。明确审查延迟或吞吐量预期、升级路径、反馈机制、可追溯性以及人工操作的可审计性。

💡 提示：
- 链接到 2.4 用户特征中定义的适用角色。

#### 3.6.6 模型生命周期和运行
💬 _定义在生产中部署、监控、再培训和退役模型的要求。_

➥ 概述模型如何从开发过渡到生产、如何监控其性能和数据质量，以及如何触发和管理再培训或回退。包括对版本和存档的预期。

## 4. 验证
💬 _描述如何验证每项要求，以提供符合要求的客观证据。_

➥ 概述验证方法（测试、金丝雀度量、分析、检查、演示）和测试证据，最好采用与第 3 节类似的矩阵。考虑添加环境细节、工具和测试数据要求。

| Requirement ID | Verification Method | Test/Artifact Link | Status | Evidence           |
|----------------|---------------------|--------------------|--------|--------------------|
| REQ-FUNC-001   | test                | tests/UC01.md      | Passed | reports/tuc01.html |
| REQ-SEC-003    | analysis            | threat-model.md    | WIP    |                    |

💡 提示：
- 包括正面和负面测试，并包括非功能验证（性能、安全性、可靠性）。
- 可对验证工件进行版本控制，并与 CI/CD 相连。
- 对于人工智能，可参考 "模型卡 "并跟踪评估数据集的版本，确保结果的可重现性。

## 5. 附录
💬 _可选的辅助材料，可帮助理解，但不具有规范性。_

➥ 包括词汇表、数据字典、模型/图表、样本数据集或支持主要部分的变化影响分析。尽可能参考而不是重复内容。

💡 提示：
- 保持附录条理清晰，并从正文中引用。
